// Code generated by rclgo-gen. DO NOT EDIT.

package gps_msgs_msg
import (
	"unsafe"

	"github.com/ATIinc/rclgo/pkg/rclgo"
	"github.com/ATIinc/rclgo/pkg/rclgo/types"
	"github.com/ATIinc/rclgo/pkg/rclgo/typemap"
	primitives "github.com/ATIinc/rclgo/pkg/rclgo/primitives"
	std_msgs_msg "github.com/iema-group/goros2/msgs/std_msgs/msg"
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <gps_msgs/msg/gps_fix.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("gps_msgs/GPSFix", GPSFixTypeSupport)
	typemap.RegisterMessage("gps_msgs/msg/GPSFix", GPSFixTypeSupport)
}
const (
	GPSFix_COVARIANCE_TYPE_UNKNOWN uint8 = 0
	GPSFix_COVARIANCE_TYPE_APPROXIMATED uint8 = 1
	GPSFix_COVARIANCE_TYPE_DIAGONAL_KNOWN uint8 = 2
	GPSFix_COVARIANCE_TYPE_KNOWN uint8 = 3
)

type GPSFix struct {
	Header std_msgs_msg.Header `yaml:"header" json:"header" mapstructure:"header"`// A more complete GPS fix to supplement sensor_msgs/NavSatFix.
	Status GPSStatus `yaml:"status" json:"status" mapstructure:"status"`
	Latitude float64 `yaml:"latitude" json:"latitude" mapstructure:"latitude"`// Latitude (degrees). Positive is north of equator; negative is south.
	Longitude float64 `yaml:"longitude" json:"longitude" mapstructure:"longitude"`// Longitude (degrees). Positive is east of prime meridian, negative west.
	Altitude float64 `yaml:"altitude" json:"altitude" mapstructure:"altitude"`// Altitude (meters). Positive is above reference (e.g., sea level).
	Track float64 `yaml:"track" json:"track" mapstructure:"track"`// Direction (degrees from north)
	Speed float64 `yaml:"speed" json:"speed" mapstructure:"speed"`// Ground speed (meters/second)
	Climb float64 `yaml:"climb" json:"climb" mapstructure:"climb"`// Vertical speed (meters/second)
	Pitch float64 `yaml:"pitch" json:"pitch" mapstructure:"pitch"`// Device orientation (units in degrees)
	Roll float64 `yaml:"roll" json:"roll" mapstructure:"roll"`
	Dip float64 `yaml:"dip" json:"dip" mapstructure:"dip"`
	Time float64 `yaml:"time" json:"time" mapstructure:"time"`// GPS time
	Gdop float64 `yaml:"gdop" json:"gdop" mapstructure:"gdop"`// Total (positional-temporal) dilution of precision
	Pdop float64 `yaml:"pdop" json:"pdop" mapstructure:"pdop"`// Positional (3D) dilution of precision
	Hdop float64 `yaml:"hdop" json:"hdop" mapstructure:"hdop"`// Horizontal dilution of precision
	Vdop float64 `yaml:"vdop" json:"vdop" mapstructure:"vdop"`// Vertical dilution of precision
	Tdop float64 `yaml:"tdop" json:"tdop" mapstructure:"tdop"`// Temporal dilution of precision
	Err float64 `yaml:"err" json:"err" mapstructure:"err"`// Spherical position uncertainty (meters) [epe]
	ErrHorz float64 `yaml:"err_horz" json:"err_horz" mapstructure:"err_horz"`// Horizontal position uncertainty (meters) [eph]
	ErrVert float64 `yaml:"err_vert" json:"err_vert" mapstructure:"err_vert"`// Vertical position uncertainty (meters) [epv]
	ErrTrack float64 `yaml:"err_track" json:"err_track" mapstructure:"err_track"`// Track uncertainty (degrees) [epd]
	ErrSpeed float64 `yaml:"err_speed" json:"err_speed" mapstructure:"err_speed"`// Ground speed uncertainty (meters/second) [eps]
	ErrClimb float64 `yaml:"err_climb" json:"err_climb" mapstructure:"err_climb"`// Vertical speed uncertainty (meters/second) [epc]
	ErrTime float64 `yaml:"err_time" json:"err_time" mapstructure:"err_time"`// Temporal uncertainty [ept]
	ErrPitch float64 `yaml:"err_pitch" json:"err_pitch" mapstructure:"err_pitch"`// Orientation uncertainty (degrees)
	ErrRoll float64 `yaml:"err_roll" json:"err_roll" mapstructure:"err_roll"`
	ErrDip float64 `yaml:"err_dip" json:"err_dip" mapstructure:"err_dip"`
	PositionCovariance [9]float64 `yaml:"position_covariance" json:"position_covariance" mapstructure:"position_covariance"`
	PositionCovarianceType uint8 `yaml:"position_covariance_type" json:"position_covariance_type" mapstructure:"position_covariance_type"`
}

// NewGPSFix creates a new GPSFix with default values.
func NewGPSFix() *GPSFix {
	self := GPSFix{}
	self.SetDefaults()
	return &self
}

func (t *GPSFix) Clone() *GPSFix {
	c := &GPSFix{}
	c.Header = *t.Header.Clone()
	c.Status = *t.Status.Clone()
	c.Latitude = t.Latitude
	c.Longitude = t.Longitude
	c.Altitude = t.Altitude
	c.Track = t.Track
	c.Speed = t.Speed
	c.Climb = t.Climb
	c.Pitch = t.Pitch
	c.Roll = t.Roll
	c.Dip = t.Dip
	c.Time = t.Time
	c.Gdop = t.Gdop
	c.Pdop = t.Pdop
	c.Hdop = t.Hdop
	c.Vdop = t.Vdop
	c.Tdop = t.Tdop
	c.Err = t.Err
	c.ErrHorz = t.ErrHorz
	c.ErrVert = t.ErrVert
	c.ErrTrack = t.ErrTrack
	c.ErrSpeed = t.ErrSpeed
	c.ErrClimb = t.ErrClimb
	c.ErrTime = t.ErrTime
	c.ErrPitch = t.ErrPitch
	c.ErrRoll = t.ErrRoll
	c.ErrDip = t.ErrDip
	c.PositionCovariance = t.PositionCovariance
	c.PositionCovarianceType = t.PositionCovarianceType
	return c
}

func (t *GPSFix) CloneMsg() types.Message {
	return t.Clone()
}

func (t *GPSFix) SetDefaults() {
	t.Header.SetDefaults()
	t.Status.SetDefaults()
	t.Latitude = 0
	t.Longitude = 0
	t.Altitude = 0
	t.Track = 0
	t.Speed = 0
	t.Climb = 0
	t.Pitch = 0
	t.Roll = 0
	t.Dip = 0
	t.Time = 0
	t.Gdop = 0
	t.Pdop = 0
	t.Hdop = 0
	t.Vdop = 0
	t.Tdop = 0
	t.Err = 0
	t.ErrHorz = 0
	t.ErrVert = 0
	t.ErrTrack = 0
	t.ErrSpeed = 0
	t.ErrClimb = 0
	t.ErrTime = 0
	t.ErrPitch = 0
	t.ErrRoll = 0
	t.ErrDip = 0
	t.PositionCovariance = [9]float64{}
	t.PositionCovarianceType = 0
}

func (t *GPSFix) GetTypeSupport() types.MessageTypeSupport {
	return GPSFixTypeSupport
}

// GPSFixPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type GPSFixPublisher struct {
	*rclgo.Publisher
}

// NewGPSFixPublisher creates and returns a new publisher for the
// GPSFix
func NewGPSFixPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*GPSFixPublisher, error) {
	pub, err := node.NewPublisher(topic_name, GPSFixTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &GPSFixPublisher{pub}, nil
}

func (p *GPSFixPublisher) Publish(msg *GPSFix) error {
	return p.Publisher.Publish(msg)
}

// GPSFixSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type GPSFixSubscription struct {
	*rclgo.Subscription
}

// GPSFixSubscriptionCallback type is used to provide a subscription
// handler function for a GPSFixSubscription.
type GPSFixSubscriptionCallback func(msg *GPSFix, info *rclgo.MessageInfo, err error)

// NewGPSFixSubscription creates and returns a new subscription for the
// GPSFix
func NewGPSFixSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback GPSFixSubscriptionCallback) (*GPSFixSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg GPSFix
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, GPSFixTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &GPSFixSubscription{sub}, nil
}

func (s *GPSFixSubscription) TakeMessage(out *GPSFix) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneGPSFixSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneGPSFixSlice(dst, src []GPSFix) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var GPSFixTypeSupport types.MessageTypeSupport = _GPSFixTypeSupport{}

type _GPSFixTypeSupport struct{}

func (t _GPSFixTypeSupport) New() types.Message {
	return NewGPSFix()
}

func (t _GPSFixTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.gps_msgs__msg__GPSFix
	return (unsafe.Pointer)(C.gps_msgs__msg__GPSFix__create())
}

func (t _GPSFixTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.gps_msgs__msg__GPSFix__destroy((*C.gps_msgs__msg__GPSFix)(pointer_to_free))
}

func (t _GPSFixTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*GPSFix)
	mem := (*C.gps_msgs__msg__GPSFix)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	GPSStatusTypeSupport.AsCStruct(unsafe.Pointer(&mem.status), &m.Status)
	mem.latitude = C.double(m.Latitude)
	mem.longitude = C.double(m.Longitude)
	mem.altitude = C.double(m.Altitude)
	mem.track = C.double(m.Track)
	mem.speed = C.double(m.Speed)
	mem.climb = C.double(m.Climb)
	mem.pitch = C.double(m.Pitch)
	mem.roll = C.double(m.Roll)
	mem.dip = C.double(m.Dip)
	mem.time = C.double(m.Time)
	mem.gdop = C.double(m.Gdop)
	mem.pdop = C.double(m.Pdop)
	mem.hdop = C.double(m.Hdop)
	mem.vdop = C.double(m.Vdop)
	mem.tdop = C.double(m.Tdop)
	mem.err = C.double(m.Err)
	mem.err_horz = C.double(m.ErrHorz)
	mem.err_vert = C.double(m.ErrVert)
	mem.err_track = C.double(m.ErrTrack)
	mem.err_speed = C.double(m.ErrSpeed)
	mem.err_climb = C.double(m.ErrClimb)
	mem.err_time = C.double(m.ErrTime)
	mem.err_pitch = C.double(m.ErrPitch)
	mem.err_roll = C.double(m.ErrRoll)
	mem.err_dip = C.double(m.ErrDip)
	cSlice_position_covariance := mem.position_covariance[:]
	primitives.Float64__Array_to_C(*(*[]primitives.CFloat64)(unsafe.Pointer(&cSlice_position_covariance)), m.PositionCovariance[:])
	mem.position_covariance_type = C.uint8_t(m.PositionCovarianceType)
}

func (t _GPSFixTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*GPSFix)
	mem := (*C.gps_msgs__msg__GPSFix)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	GPSStatusTypeSupport.AsGoStruct(&m.Status, unsafe.Pointer(&mem.status))
	m.Latitude = float64(mem.latitude)
	m.Longitude = float64(mem.longitude)
	m.Altitude = float64(mem.altitude)
	m.Track = float64(mem.track)
	m.Speed = float64(mem.speed)
	m.Climb = float64(mem.climb)
	m.Pitch = float64(mem.pitch)
	m.Roll = float64(mem.roll)
	m.Dip = float64(mem.dip)
	m.Time = float64(mem.time)
	m.Gdop = float64(mem.gdop)
	m.Pdop = float64(mem.pdop)
	m.Hdop = float64(mem.hdop)
	m.Vdop = float64(mem.vdop)
	m.Tdop = float64(mem.tdop)
	m.Err = float64(mem.err)
	m.ErrHorz = float64(mem.err_horz)
	m.ErrVert = float64(mem.err_vert)
	m.ErrTrack = float64(mem.err_track)
	m.ErrSpeed = float64(mem.err_speed)
	m.ErrClimb = float64(mem.err_climb)
	m.ErrTime = float64(mem.err_time)
	m.ErrPitch = float64(mem.err_pitch)
	m.ErrRoll = float64(mem.err_roll)
	m.ErrDip = float64(mem.err_dip)
	cSlice_position_covariance := mem.position_covariance[:]
	primitives.Float64__Array_to_Go(m.PositionCovariance[:], *(*[]primitives.CFloat64)(unsafe.Pointer(&cSlice_position_covariance)))
	m.PositionCovarianceType = uint8(mem.position_covariance_type)
}

func (t _GPSFixTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__gps_msgs__msg__GPSFix())
}

type CGPSFix = C.gps_msgs__msg__GPSFix
type CGPSFix__Sequence = C.gps_msgs__msg__GPSFix__Sequence

func GPSFix__Sequence_to_Go(goSlice *[]GPSFix, cSlice CGPSFix__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]GPSFix, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		GPSFixTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func GPSFix__Sequence_to_C(cSlice *CGPSFix__Sequence, goSlice []GPSFix) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.gps_msgs__msg__GPSFix)(C.malloc(C.sizeof_struct_gps_msgs__msg__GPSFix * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		GPSFixTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func GPSFix__Array_to_Go(goSlice []GPSFix, cSlice []CGPSFix) {
	for i := 0; i < len(cSlice); i++ {
		GPSFixTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func GPSFix__Array_to_C(cSlice []CGPSFix, goSlice []GPSFix) {
	for i := 0; i < len(goSlice); i++ {
		GPSFixTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
