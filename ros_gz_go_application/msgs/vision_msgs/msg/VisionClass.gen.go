// Code generated by rclgo-gen. DO NOT EDIT.

package vision_msgs_msg
import (
	"unsafe"

	"github.com/ATIinc/rclgo/pkg/rclgo"
	"github.com/ATIinc/rclgo/pkg/rclgo/types"
	"github.com/ATIinc/rclgo/pkg/rclgo/typemap"
	primitives "github.com/ATIinc/rclgo/pkg/rclgo/primitives"
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <vision_msgs/msg/vision_class.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("vision_msgs/VisionClass", VisionClassTypeSupport)
	typemap.RegisterMessage("vision_msgs/msg/VisionClass", VisionClassTypeSupport)
}

type VisionClass struct {
	ClassId uint16 `yaml:"class_id" json:"class_id" mapstructure:"class_id"`// The int value that identifies the class.Elements identified with 65535, the maximum uint16 value are assumedto belong to the "UNLABELED" class. For vision pipelines using lessthan 255 classes the "UNLABELED" is the maximum value in the uint8range.
	ClassName string `yaml:"class_name" json:"class_name" mapstructure:"class_name"`// The name of the class represented by the class_id
}

// NewVisionClass creates a new VisionClass with default values.
func NewVisionClass() *VisionClass {
	self := VisionClass{}
	self.SetDefaults()
	return &self
}

func (t *VisionClass) Clone() *VisionClass {
	c := &VisionClass{}
	c.ClassId = t.ClassId
	c.ClassName = t.ClassName
	return c
}

func (t *VisionClass) CloneMsg() types.Message {
	return t.Clone()
}

func (t *VisionClass) SetDefaults() {
	t.ClassId = 0
	t.ClassName = ""
}

func (t *VisionClass) GetTypeSupport() types.MessageTypeSupport {
	return VisionClassTypeSupport
}

// VisionClassPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type VisionClassPublisher struct {
	*rclgo.Publisher
}

// NewVisionClassPublisher creates and returns a new publisher for the
// VisionClass
func NewVisionClassPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*VisionClassPublisher, error) {
	pub, err := node.NewPublisher(topic_name, VisionClassTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &VisionClassPublisher{pub}, nil
}

func (p *VisionClassPublisher) Publish(msg *VisionClass) error {
	return p.Publisher.Publish(msg)
}

// VisionClassSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type VisionClassSubscription struct {
	*rclgo.Subscription
}

// VisionClassSubscriptionCallback type is used to provide a subscription
// handler function for a VisionClassSubscription.
type VisionClassSubscriptionCallback func(msg *VisionClass, info *rclgo.MessageInfo, err error)

// NewVisionClassSubscription creates and returns a new subscription for the
// VisionClass
func NewVisionClassSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback VisionClassSubscriptionCallback) (*VisionClassSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg VisionClass
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, VisionClassTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &VisionClassSubscription{sub}, nil
}

func (s *VisionClassSubscription) TakeMessage(out *VisionClass) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneVisionClassSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneVisionClassSlice(dst, src []VisionClass) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var VisionClassTypeSupport types.MessageTypeSupport = _VisionClassTypeSupport{}

type _VisionClassTypeSupport struct{}

func (t _VisionClassTypeSupport) New() types.Message {
	return NewVisionClass()
}

func (t _VisionClassTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.vision_msgs__msg__VisionClass
	return (unsafe.Pointer)(C.vision_msgs__msg__VisionClass__create())
}

func (t _VisionClassTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.vision_msgs__msg__VisionClass__destroy((*C.vision_msgs__msg__VisionClass)(pointer_to_free))
}

func (t _VisionClassTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*VisionClass)
	mem := (*C.vision_msgs__msg__VisionClass)(dst)
	mem.class_id = C.uint16_t(m.ClassId)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.class_name), m.ClassName)
}

func (t _VisionClassTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*VisionClass)
	mem := (*C.vision_msgs__msg__VisionClass)(ros2_message_buffer)
	m.ClassId = uint16(mem.class_id)
	primitives.StringAsGoStruct(&m.ClassName, unsafe.Pointer(&mem.class_name))
}

func (t _VisionClassTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__VisionClass())
}

type CVisionClass = C.vision_msgs__msg__VisionClass
type CVisionClass__Sequence = C.vision_msgs__msg__VisionClass__Sequence

func VisionClass__Sequence_to_Go(goSlice *[]VisionClass, cSlice CVisionClass__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]VisionClass, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		VisionClassTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func VisionClass__Sequence_to_C(cSlice *CVisionClass__Sequence, goSlice []VisionClass) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.vision_msgs__msg__VisionClass)(C.malloc(C.sizeof_struct_vision_msgs__msg__VisionClass * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		VisionClassTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func VisionClass__Array_to_Go(goSlice []VisionClass, cSlice []CVisionClass) {
	for i := 0; i < len(cSlice); i++ {
		VisionClassTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func VisionClass__Array_to_C(cSlice []CVisionClass, goSlice []VisionClass) {
	for i := 0; i < len(goSlice); i++ {
		VisionClassTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
