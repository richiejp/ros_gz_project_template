// Code generated by rclgo-gen. DO NOT EDIT.

package vision_msgs_msg
import (
	"unsafe"

	"github.com/ATIinc/rclgo/pkg/rclgo"
	"github.com/ATIinc/rclgo/pkg/rclgo/types"
	"github.com/ATIinc/rclgo/pkg/rclgo/typemap"
	primitives "github.com/ATIinc/rclgo/pkg/rclgo/primitives"
	std_msgs_msg "github.com/iema-group/goros2/msgs/std_msgs/msg"
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <vision_msgs/msg/vision_info.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("vision_msgs/VisionInfo", VisionInfoTypeSupport)
	typemap.RegisterMessage("vision_msgs/msg/VisionInfo", VisionInfoTypeSupport)
}

type VisionInfo struct {
	Header std_msgs_msg.Header `yaml:"header" json:"header" mapstructure:"header"`// Used for sequencing
	Method string `yaml:"method" json:"method" mapstructure:"method"`// Name of the vision pipeline. This should be a value that is meaningful to anoutside user.
	DatabaseLocation string `yaml:"database_location" json:"database_location" mapstructure:"database_location"`// Location where the metadata database is stored. The recommended location isas an XML string on the ROS parameter server, but the exact implementationand information is left up to the user.The database should store information attached to class ids. Eachclass id should map to an atomic, visually recognizable element. Thisdefinition is intentionally vague to allow extreme flexibility. Theelements could be classes in a pixel segmentation algorithm, object classesin a detector, different people's faces in a face detection algorithm, etc.Vision pipelines report results in terms of numeric IDs, which map intothis  database.The information stored in this database is, again, left up to the user. Thedatabase could be as simple as a map from ID to class name, or it couldinclude information such as object meshes or colors to use forvisualization.
	DatabaseVersion int32 `yaml:"database_version" json:"database_version" mapstructure:"database_version"`// Metadata database version. This counter is incrementedeach time the pipeline begins using a new version of the database (usefulin the case of online training or user modifications).The counter value can be monitored by listeners to ensure that the pipelineand the listener are using the same metadata.
}

// NewVisionInfo creates a new VisionInfo with default values.
func NewVisionInfo() *VisionInfo {
	self := VisionInfo{}
	self.SetDefaults()
	return &self
}

func (t *VisionInfo) Clone() *VisionInfo {
	c := &VisionInfo{}
	c.Header = *t.Header.Clone()
	c.Method = t.Method
	c.DatabaseLocation = t.DatabaseLocation
	c.DatabaseVersion = t.DatabaseVersion
	return c
}

func (t *VisionInfo) CloneMsg() types.Message {
	return t.Clone()
}

func (t *VisionInfo) SetDefaults() {
	t.Header.SetDefaults()
	t.Method = ""
	t.DatabaseLocation = ""
	t.DatabaseVersion = 0
}

func (t *VisionInfo) GetTypeSupport() types.MessageTypeSupport {
	return VisionInfoTypeSupport
}

// VisionInfoPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type VisionInfoPublisher struct {
	*rclgo.Publisher
}

// NewVisionInfoPublisher creates and returns a new publisher for the
// VisionInfo
func NewVisionInfoPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*VisionInfoPublisher, error) {
	pub, err := node.NewPublisher(topic_name, VisionInfoTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &VisionInfoPublisher{pub}, nil
}

func (p *VisionInfoPublisher) Publish(msg *VisionInfo) error {
	return p.Publisher.Publish(msg)
}

// VisionInfoSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type VisionInfoSubscription struct {
	*rclgo.Subscription
}

// VisionInfoSubscriptionCallback type is used to provide a subscription
// handler function for a VisionInfoSubscription.
type VisionInfoSubscriptionCallback func(msg *VisionInfo, info *rclgo.MessageInfo, err error)

// NewVisionInfoSubscription creates and returns a new subscription for the
// VisionInfo
func NewVisionInfoSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback VisionInfoSubscriptionCallback) (*VisionInfoSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg VisionInfo
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, VisionInfoTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &VisionInfoSubscription{sub}, nil
}

func (s *VisionInfoSubscription) TakeMessage(out *VisionInfo) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneVisionInfoSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneVisionInfoSlice(dst, src []VisionInfo) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var VisionInfoTypeSupport types.MessageTypeSupport = _VisionInfoTypeSupport{}

type _VisionInfoTypeSupport struct{}

func (t _VisionInfoTypeSupport) New() types.Message {
	return NewVisionInfo()
}

func (t _VisionInfoTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.vision_msgs__msg__VisionInfo
	return (unsafe.Pointer)(C.vision_msgs__msg__VisionInfo__create())
}

func (t _VisionInfoTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.vision_msgs__msg__VisionInfo__destroy((*C.vision_msgs__msg__VisionInfo)(pointer_to_free))
}

func (t _VisionInfoTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*VisionInfo)
	mem := (*C.vision_msgs__msg__VisionInfo)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.method), m.Method)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.database_location), m.DatabaseLocation)
	mem.database_version = C.int32_t(m.DatabaseVersion)
}

func (t _VisionInfoTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*VisionInfo)
	mem := (*C.vision_msgs__msg__VisionInfo)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	primitives.StringAsGoStruct(&m.Method, unsafe.Pointer(&mem.method))
	primitives.StringAsGoStruct(&m.DatabaseLocation, unsafe.Pointer(&mem.database_location))
	m.DatabaseVersion = int32(mem.database_version)
}

func (t _VisionInfoTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__VisionInfo())
}

type CVisionInfo = C.vision_msgs__msg__VisionInfo
type CVisionInfo__Sequence = C.vision_msgs__msg__VisionInfo__Sequence

func VisionInfo__Sequence_to_Go(goSlice *[]VisionInfo, cSlice CVisionInfo__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]VisionInfo, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		VisionInfoTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func VisionInfo__Sequence_to_C(cSlice *CVisionInfo__Sequence, goSlice []VisionInfo) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.vision_msgs__msg__VisionInfo)(C.malloc(C.sizeof_struct_vision_msgs__msg__VisionInfo * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		VisionInfoTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func VisionInfo__Array_to_Go(goSlice []VisionInfo, cSlice []CVisionInfo) {
	for i := 0; i < len(cSlice); i++ {
		VisionInfoTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func VisionInfo__Array_to_C(cSlice []CVisionInfo, goSlice []VisionInfo) {
	for i := 0; i < len(goSlice); i++ {
		VisionInfoTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
