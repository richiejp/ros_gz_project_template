// Code generated by rclgo-gen. DO NOT EDIT.

package vision_msgs_msg
import (
	"unsafe"

	"github.com/ATIinc/rclgo/pkg/rclgo"
	"github.com/ATIinc/rclgo/pkg/rclgo/types"
	"github.com/ATIinc/rclgo/pkg/rclgo/typemap"
	std_msgs_msg "github.com/iema-group/goros2/msgs/std_msgs/msg"
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <vision_msgs/msg/label_info.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("vision_msgs/LabelInfo", LabelInfoTypeSupport)
	typemap.RegisterMessage("vision_msgs/msg/LabelInfo", LabelInfoTypeSupport)
}

type LabelInfo struct {
	Header std_msgs_msg.Header `yaml:"header" json:"header" mapstructure:"header"`// Used for sequencing
	ClassMap []VisionClass `yaml:"class_map" json:"class_map" mapstructure:"class_map"`// An array of uint16 keys and string values containing the associationbetween class identifiers and their names. According to the amountof classes and the datatype used to store their ids internally, themaxiumum class id allowed (65535 for uint16 and 255 for uint8) belongs tothe "UNLABELED" class.
	Threshold float32 `yaml:"threshold" json:"threshold" mapstructure:"threshold"`// The value between 0-1 used as confidence threshold for the inference.
}

// NewLabelInfo creates a new LabelInfo with default values.
func NewLabelInfo() *LabelInfo {
	self := LabelInfo{}
	self.SetDefaults()
	return &self
}

func (t *LabelInfo) Clone() *LabelInfo {
	c := &LabelInfo{}
	c.Header = *t.Header.Clone()
	if t.ClassMap != nil {
		c.ClassMap = make([]VisionClass, len(t.ClassMap))
		CloneVisionClassSlice(c.ClassMap, t.ClassMap)
	}
	c.Threshold = t.Threshold
	return c
}

func (t *LabelInfo) CloneMsg() types.Message {
	return t.Clone()
}

func (t *LabelInfo) SetDefaults() {
	t.Header.SetDefaults()
	t.ClassMap = nil
	t.Threshold = 0
}

func (t *LabelInfo) GetTypeSupport() types.MessageTypeSupport {
	return LabelInfoTypeSupport
}

// LabelInfoPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type LabelInfoPublisher struct {
	*rclgo.Publisher
}

// NewLabelInfoPublisher creates and returns a new publisher for the
// LabelInfo
func NewLabelInfoPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*LabelInfoPublisher, error) {
	pub, err := node.NewPublisher(topic_name, LabelInfoTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &LabelInfoPublisher{pub}, nil
}

func (p *LabelInfoPublisher) Publish(msg *LabelInfo) error {
	return p.Publisher.Publish(msg)
}

// LabelInfoSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type LabelInfoSubscription struct {
	*rclgo.Subscription
}

// LabelInfoSubscriptionCallback type is used to provide a subscription
// handler function for a LabelInfoSubscription.
type LabelInfoSubscriptionCallback func(msg *LabelInfo, info *rclgo.MessageInfo, err error)

// NewLabelInfoSubscription creates and returns a new subscription for the
// LabelInfo
func NewLabelInfoSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback LabelInfoSubscriptionCallback) (*LabelInfoSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg LabelInfo
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, LabelInfoTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &LabelInfoSubscription{sub}, nil
}

func (s *LabelInfoSubscription) TakeMessage(out *LabelInfo) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneLabelInfoSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneLabelInfoSlice(dst, src []LabelInfo) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var LabelInfoTypeSupport types.MessageTypeSupport = _LabelInfoTypeSupport{}

type _LabelInfoTypeSupport struct{}

func (t _LabelInfoTypeSupport) New() types.Message {
	return NewLabelInfo()
}

func (t _LabelInfoTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.vision_msgs__msg__LabelInfo
	return (unsafe.Pointer)(C.vision_msgs__msg__LabelInfo__create())
}

func (t _LabelInfoTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.vision_msgs__msg__LabelInfo__destroy((*C.vision_msgs__msg__LabelInfo)(pointer_to_free))
}

func (t _LabelInfoTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*LabelInfo)
	mem := (*C.vision_msgs__msg__LabelInfo)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	VisionClass__Sequence_to_C(&mem.class_map, m.ClassMap)
	mem.threshold = C.float(m.Threshold)
}

func (t _LabelInfoTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*LabelInfo)
	mem := (*C.vision_msgs__msg__LabelInfo)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	VisionClass__Sequence_to_Go(&m.ClassMap, mem.class_map)
	m.Threshold = float32(mem.threshold)
}

func (t _LabelInfoTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__LabelInfo())
}

type CLabelInfo = C.vision_msgs__msg__LabelInfo
type CLabelInfo__Sequence = C.vision_msgs__msg__LabelInfo__Sequence

func LabelInfo__Sequence_to_Go(goSlice *[]LabelInfo, cSlice CLabelInfo__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]LabelInfo, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		LabelInfoTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func LabelInfo__Sequence_to_C(cSlice *CLabelInfo__Sequence, goSlice []LabelInfo) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.vision_msgs__msg__LabelInfo)(C.malloc(C.sizeof_struct_vision_msgs__msg__LabelInfo * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		LabelInfoTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func LabelInfo__Array_to_Go(goSlice []LabelInfo, cSlice []CLabelInfo) {
	for i := 0; i < len(cSlice); i++ {
		LabelInfoTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func LabelInfo__Array_to_C(cSlice []CLabelInfo, goSlice []LabelInfo) {
	for i := 0; i < len(goSlice); i++ {
		LabelInfoTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
