// Code generated by rclgo-gen. DO NOT EDIT.

package vision_msgs_msg
import (
	"unsafe"

	"github.com/ATIinc/rclgo/pkg/rclgo"
	"github.com/ATIinc/rclgo/pkg/rclgo/types"
	"github.com/ATIinc/rclgo/pkg/rclgo/typemap"
	geometry_msgs_msg "github.com/iema-group/goros2/msgs/geometry_msgs/msg"
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <vision_msgs/msg/object_hypothesis_with_pose.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("vision_msgs/ObjectHypothesisWithPose", ObjectHypothesisWithPoseTypeSupport)
	typemap.RegisterMessage("vision_msgs/msg/ObjectHypothesisWithPose", ObjectHypothesisWithPoseTypeSupport)
}

type ObjectHypothesisWithPose struct {
	Hypothesis ObjectHypothesis `yaml:"hypothesis" json:"hypothesis" mapstructure:"hypothesis"`// The object hypothesis (ID and score).
	Pose geometry_msgs_msg.PoseWithCovariance `yaml:"pose" json:"pose" mapstructure:"pose"`// The 6D pose of the object hypothesis. This pose should bedefined as the pose of some fixed reference point on the object, such asthe geometric center of the bounding box, the center of mass of theobject or the origin of a reference mesh of the object.Note that this pose is not stamped; frame information can be defined byparent messages.Also note that different classes predicted for the same input data may havedifferent predicted 6D poses.
}

// NewObjectHypothesisWithPose creates a new ObjectHypothesisWithPose with default values.
func NewObjectHypothesisWithPose() *ObjectHypothesisWithPose {
	self := ObjectHypothesisWithPose{}
	self.SetDefaults()
	return &self
}

func (t *ObjectHypothesisWithPose) Clone() *ObjectHypothesisWithPose {
	c := &ObjectHypothesisWithPose{}
	c.Hypothesis = *t.Hypothesis.Clone()
	c.Pose = *t.Pose.Clone()
	return c
}

func (t *ObjectHypothesisWithPose) CloneMsg() types.Message {
	return t.Clone()
}

func (t *ObjectHypothesisWithPose) SetDefaults() {
	t.Hypothesis.SetDefaults()
	t.Pose.SetDefaults()
}

func (t *ObjectHypothesisWithPose) GetTypeSupport() types.MessageTypeSupport {
	return ObjectHypothesisWithPoseTypeSupport
}

// ObjectHypothesisWithPosePublisher wraps rclgo.Publisher to provide type safe helper
// functions
type ObjectHypothesisWithPosePublisher struct {
	*rclgo.Publisher
}

// NewObjectHypothesisWithPosePublisher creates and returns a new publisher for the
// ObjectHypothesisWithPose
func NewObjectHypothesisWithPosePublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*ObjectHypothesisWithPosePublisher, error) {
	pub, err := node.NewPublisher(topic_name, ObjectHypothesisWithPoseTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &ObjectHypothesisWithPosePublisher{pub}, nil
}

func (p *ObjectHypothesisWithPosePublisher) Publish(msg *ObjectHypothesisWithPose) error {
	return p.Publisher.Publish(msg)
}

// ObjectHypothesisWithPoseSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type ObjectHypothesisWithPoseSubscription struct {
	*rclgo.Subscription
}

// ObjectHypothesisWithPoseSubscriptionCallback type is used to provide a subscription
// handler function for a ObjectHypothesisWithPoseSubscription.
type ObjectHypothesisWithPoseSubscriptionCallback func(msg *ObjectHypothesisWithPose, info *rclgo.MessageInfo, err error)

// NewObjectHypothesisWithPoseSubscription creates and returns a new subscription for the
// ObjectHypothesisWithPose
func NewObjectHypothesisWithPoseSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback ObjectHypothesisWithPoseSubscriptionCallback) (*ObjectHypothesisWithPoseSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg ObjectHypothesisWithPose
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, ObjectHypothesisWithPoseTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &ObjectHypothesisWithPoseSubscription{sub}, nil
}

func (s *ObjectHypothesisWithPoseSubscription) TakeMessage(out *ObjectHypothesisWithPose) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneObjectHypothesisWithPoseSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneObjectHypothesisWithPoseSlice(dst, src []ObjectHypothesisWithPose) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var ObjectHypothesisWithPoseTypeSupport types.MessageTypeSupport = _ObjectHypothesisWithPoseTypeSupport{}

type _ObjectHypothesisWithPoseTypeSupport struct{}

func (t _ObjectHypothesisWithPoseTypeSupport) New() types.Message {
	return NewObjectHypothesisWithPose()
}

func (t _ObjectHypothesisWithPoseTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.vision_msgs__msg__ObjectHypothesisWithPose
	return (unsafe.Pointer)(C.vision_msgs__msg__ObjectHypothesisWithPose__create())
}

func (t _ObjectHypothesisWithPoseTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.vision_msgs__msg__ObjectHypothesisWithPose__destroy((*C.vision_msgs__msg__ObjectHypothesisWithPose)(pointer_to_free))
}

func (t _ObjectHypothesisWithPoseTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*ObjectHypothesisWithPose)
	mem := (*C.vision_msgs__msg__ObjectHypothesisWithPose)(dst)
	ObjectHypothesisTypeSupport.AsCStruct(unsafe.Pointer(&mem.hypothesis), &m.Hypothesis)
	geometry_msgs_msg.PoseWithCovarianceTypeSupport.AsCStruct(unsafe.Pointer(&mem.pose), &m.Pose)
}

func (t _ObjectHypothesisWithPoseTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*ObjectHypothesisWithPose)
	mem := (*C.vision_msgs__msg__ObjectHypothesisWithPose)(ros2_message_buffer)
	ObjectHypothesisTypeSupport.AsGoStruct(&m.Hypothesis, unsafe.Pointer(&mem.hypothesis))
	geometry_msgs_msg.PoseWithCovarianceTypeSupport.AsGoStruct(&m.Pose, unsafe.Pointer(&mem.pose))
}

func (t _ObjectHypothesisWithPoseTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__ObjectHypothesisWithPose())
}

type CObjectHypothesisWithPose = C.vision_msgs__msg__ObjectHypothesisWithPose
type CObjectHypothesisWithPose__Sequence = C.vision_msgs__msg__ObjectHypothesisWithPose__Sequence

func ObjectHypothesisWithPose__Sequence_to_Go(goSlice *[]ObjectHypothesisWithPose, cSlice CObjectHypothesisWithPose__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]ObjectHypothesisWithPose, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		ObjectHypothesisWithPoseTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func ObjectHypothesisWithPose__Sequence_to_C(cSlice *CObjectHypothesisWithPose__Sequence, goSlice []ObjectHypothesisWithPose) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.vision_msgs__msg__ObjectHypothesisWithPose)(C.malloc(C.sizeof_struct_vision_msgs__msg__ObjectHypothesisWithPose * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		ObjectHypothesisWithPoseTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func ObjectHypothesisWithPose__Array_to_Go(goSlice []ObjectHypothesisWithPose, cSlice []CObjectHypothesisWithPose) {
	for i := 0; i < len(cSlice); i++ {
		ObjectHypothesisWithPoseTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func ObjectHypothesisWithPose__Array_to_C(cSlice []CObjectHypothesisWithPose, goSlice []ObjectHypothesisWithPose) {
	for i := 0; i < len(goSlice); i++ {
		ObjectHypothesisWithPoseTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
