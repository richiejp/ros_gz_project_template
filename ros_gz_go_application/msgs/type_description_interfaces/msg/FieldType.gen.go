// Code generated by rclgo-gen. DO NOT EDIT.

package type_description_interfaces_msg
import (
	"unsafe"

	"github.com/ATIinc/rclgo/pkg/rclgo"
	"github.com/ATIinc/rclgo/pkg/rclgo/types"
	"github.com/ATIinc/rclgo/pkg/rclgo/typemap"
	primitives "github.com/ATIinc/rclgo/pkg/rclgo/primitives"
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <type_description_interfaces/msg/field_type.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("type_description_interfaces/FieldType", FieldTypeTypeSupport)
	typemap.RegisterMessage("type_description_interfaces/msg/FieldType", FieldTypeTypeSupport)
}
const (
	FieldType_FIELD_TYPE_NOT_SET uint8 = 0
	FieldType_FIELD_TYPE_NESTED_TYPE uint8 = 1// Nested type defined in other .msg/.idl files.
	FieldType_FIELD_TYPE_INT8 uint8 = 2// Integer Types
	FieldType_FIELD_TYPE_UINT8 uint8 = 3
	FieldType_FIELD_TYPE_INT16 uint8 = 4
	FieldType_FIELD_TYPE_UINT16 uint8 = 5
	FieldType_FIELD_TYPE_INT32 uint8 = 6
	FieldType_FIELD_TYPE_UINT32 uint8 = 7
	FieldType_FIELD_TYPE_INT64 uint8 = 8
	FieldType_FIELD_TYPE_UINT64 uint8 = 9
	FieldType_FIELD_TYPE_FLOAT uint8 = 10// Floating-Point Types
	FieldType_FIELD_TYPE_DOUBLE uint8 = 11
	FieldType_FIELD_TYPE_LONG_DOUBLE uint8 = 12
	FieldType_FIELD_TYPE_CHAR uint8 = 13// Char and WChar Types
	FieldType_FIELD_TYPE_WCHAR uint8 = 14
	FieldType_FIELD_TYPE_BOOLEAN uint8 = 15// Boolean Type
	FieldType_FIELD_TYPE_BYTE uint8 = 16// Byte/Octet Type
	FieldType_FIELD_TYPE_STRING uint8 = 17// String Types
	FieldType_FIELD_TYPE_WSTRING uint8 = 18
	FieldType_FIELD_TYPE_FIXED_STRING uint8 = 19// Fixed String Types
	FieldType_FIELD_TYPE_FIXED_WSTRING uint8 = 20
	FieldType_FIELD_TYPE_BOUNDED_STRING uint8 = 21// Bounded String Types
	FieldType_FIELD_TYPE_BOUNDED_WSTRING uint8 = 22
	FieldType_FIELD_TYPE_NESTED_TYPE_ARRAY uint8 = 49// Fixed Sized Array Types
	FieldType_FIELD_TYPE_INT8_ARRAY uint8 = 50
	FieldType_FIELD_TYPE_UINT8_ARRAY uint8 = 51
	FieldType_FIELD_TYPE_INT16_ARRAY uint8 = 52
	FieldType_FIELD_TYPE_UINT16_ARRAY uint8 = 53
	FieldType_FIELD_TYPE_INT32_ARRAY uint8 = 54
	FieldType_FIELD_TYPE_UINT32_ARRAY uint8 = 55
	FieldType_FIELD_TYPE_INT64_ARRAY uint8 = 56
	FieldType_FIELD_TYPE_UINT64_ARRAY uint8 = 57
	FieldType_FIELD_TYPE_FLOAT_ARRAY uint8 = 58
	FieldType_FIELD_TYPE_DOUBLE_ARRAY uint8 = 59
	FieldType_FIELD_TYPE_LONG_DOUBLE_ARRAY uint8 = 60
	FieldType_FIELD_TYPE_CHAR_ARRAY uint8 = 61
	FieldType_FIELD_TYPE_WCHAR_ARRAY uint8 = 62
	FieldType_FIELD_TYPE_BOOLEAN_ARRAY uint8 = 63
	FieldType_FIELD_TYPE_BYTE_ARRAY uint8 = 64
	FieldType_FIELD_TYPE_STRING_ARRAY uint8 = 65
	FieldType_FIELD_TYPE_WSTRING_ARRAY uint8 = 66
	FieldType_FIELD_TYPE_FIXED_STRING_ARRAY uint8 = 67
	FieldType_FIELD_TYPE_FIXED_WSTRING_ARRAY uint8 = 68
	FieldType_FIELD_TYPE_BOUNDED_STRING_ARRAY uint8 = 69
	FieldType_FIELD_TYPE_BOUNDED_WSTRING_ARRAY uint8 = 70
	FieldType_FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE uint8 = 97// Bounded Sequence Types
	FieldType_FIELD_TYPE_INT8_BOUNDED_SEQUENCE uint8 = 98
	FieldType_FIELD_TYPE_UINT8_BOUNDED_SEQUENCE uint8 = 99
	FieldType_FIELD_TYPE_INT16_BOUNDED_SEQUENCE uint8 = 100
	FieldType_FIELD_TYPE_UINT16_BOUNDED_SEQUENCE uint8 = 101
	FieldType_FIELD_TYPE_INT32_BOUNDED_SEQUENCE uint8 = 102
	FieldType_FIELD_TYPE_UINT32_BOUNDED_SEQUENCE uint8 = 103
	FieldType_FIELD_TYPE_INT64_BOUNDED_SEQUENCE uint8 = 104
	FieldType_FIELD_TYPE_UINT64_BOUNDED_SEQUENCE uint8 = 105
	FieldType_FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE uint8 = 106
	FieldType_FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE uint8 = 107
	FieldType_FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE uint8 = 108
	FieldType_FIELD_TYPE_CHAR_BOUNDED_SEQUENCE uint8 = 109
	FieldType_FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE uint8 = 110
	FieldType_FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE uint8 = 111
	FieldType_FIELD_TYPE_BYTE_BOUNDED_SEQUENCE uint8 = 112
	FieldType_FIELD_TYPE_STRING_BOUNDED_SEQUENCE uint8 = 113
	FieldType_FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE uint8 = 114
	FieldType_FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE uint8 = 115
	FieldType_FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE uint8 = 116
	FieldType_FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE uint8 = 117
	FieldType_FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE uint8 = 118
	FieldType_FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE uint8 = 145// Unbounded Sequence Types
	FieldType_FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE uint8 = 146
	FieldType_FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE uint8 = 147
	FieldType_FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE uint8 = 148
	FieldType_FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE uint8 = 149
	FieldType_FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE uint8 = 150
	FieldType_FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE uint8 = 151
	FieldType_FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE uint8 = 152
	FieldType_FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE uint8 = 153
	FieldType_FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE uint8 = 154
	FieldType_FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE uint8 = 155
	FieldType_FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE uint8 = 156
	FieldType_FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE uint8 = 157
	FieldType_FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE uint8 = 158
	FieldType_FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE uint8 = 159
	FieldType_FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE uint8 = 160
	FieldType_FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE uint8 = 161
	FieldType_FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE uint8 = 162
	FieldType_FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE uint8 = 163
	FieldType_FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE uint8 = 164
	FieldType_FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE uint8 = 165
	FieldType_FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE uint8 = 166
)

type FieldType struct {
	TypeId uint8 `yaml:"type_id" json:"type_id" mapstructure:"type_id"`// Identifying number for the type of the field, using one of the above constants.
	Capacity uint64 `yaml:"capacity" json:"capacity" mapstructure:"capacity"`// Only used when the type is an array or a bounded sequence.In the case of an array, this is the fixed capacity of the array.In the case of a bounded sequence, this is the maximum capacity of the sequence.In all other cases this field is unused.
	StringCapacity uint64 `yaml:"string_capacity" json:"string_capacity" mapstructure:"string_capacity"`// Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.In the case of a fixed string/wstring, it is the fixed length of the string.In the case of a bounded string/wstring, it is the maximum capacity of the string.In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.It is not currently possible to have different string capacities per element in the array/sequence.
	NestedTypeName string `yaml:"nested_type_name" json:"nested_type_name" mapstructure:"nested_type_name"`// Only used when the type is a nested type or array/sequence of nested types.This is limited to 255 characters.TODO(wjwwood): this 255 character limit was chosen due to this being the limitfor DDSI-RTPS based middlewares, which is the most commonly used right now.We lack a ROS 2 specific limit in our design documents, but we should updatethis and/or link to the design doc when that is available.
}

// NewFieldType creates a new FieldType with default values.
func NewFieldType() *FieldType {
	self := FieldType{}
	self.SetDefaults()
	return &self
}

func (t *FieldType) Clone() *FieldType {
	c := &FieldType{}
	c.TypeId = t.TypeId
	c.Capacity = t.Capacity
	c.StringCapacity = t.StringCapacity
	c.NestedTypeName = t.NestedTypeName
	return c
}

func (t *FieldType) CloneMsg() types.Message {
	return t.Clone()
}

func (t *FieldType) SetDefaults() {
	t.TypeId = 0
	t.Capacity = 0
	t.StringCapacity = 0
	t.NestedTypeName = ""
}

func (t *FieldType) GetTypeSupport() types.MessageTypeSupport {
	return FieldTypeTypeSupport
}

// FieldTypePublisher wraps rclgo.Publisher to provide type safe helper
// functions
type FieldTypePublisher struct {
	*rclgo.Publisher
}

// NewFieldTypePublisher creates and returns a new publisher for the
// FieldType
func NewFieldTypePublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*FieldTypePublisher, error) {
	pub, err := node.NewPublisher(topic_name, FieldTypeTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &FieldTypePublisher{pub}, nil
}

func (p *FieldTypePublisher) Publish(msg *FieldType) error {
	return p.Publisher.Publish(msg)
}

// FieldTypeSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type FieldTypeSubscription struct {
	*rclgo.Subscription
}

// FieldTypeSubscriptionCallback type is used to provide a subscription
// handler function for a FieldTypeSubscription.
type FieldTypeSubscriptionCallback func(msg *FieldType, info *rclgo.MessageInfo, err error)

// NewFieldTypeSubscription creates and returns a new subscription for the
// FieldType
func NewFieldTypeSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback FieldTypeSubscriptionCallback) (*FieldTypeSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg FieldType
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, FieldTypeTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &FieldTypeSubscription{sub}, nil
}

func (s *FieldTypeSubscription) TakeMessage(out *FieldType) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneFieldTypeSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneFieldTypeSlice(dst, src []FieldType) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var FieldTypeTypeSupport types.MessageTypeSupport = _FieldTypeTypeSupport{}

type _FieldTypeTypeSupport struct{}

func (t _FieldTypeTypeSupport) New() types.Message {
	return NewFieldType()
}

func (t _FieldTypeTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.type_description_interfaces__msg__FieldType
	return (unsafe.Pointer)(C.type_description_interfaces__msg__FieldType__create())
}

func (t _FieldTypeTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.type_description_interfaces__msg__FieldType__destroy((*C.type_description_interfaces__msg__FieldType)(pointer_to_free))
}

func (t _FieldTypeTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*FieldType)
	mem := (*C.type_description_interfaces__msg__FieldType)(dst)
	mem.type_id = C.uint8_t(m.TypeId)
	mem.capacity = C.uint64_t(m.Capacity)
	mem.string_capacity = C.uint64_t(m.StringCapacity)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.nested_type_name), m.NestedTypeName)
}

func (t _FieldTypeTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*FieldType)
	mem := (*C.type_description_interfaces__msg__FieldType)(ros2_message_buffer)
	m.TypeId = uint8(mem.type_id)
	m.Capacity = uint64(mem.capacity)
	m.StringCapacity = uint64(mem.string_capacity)
	primitives.StringAsGoStruct(&m.NestedTypeName, unsafe.Pointer(&mem.nested_type_name))
}

func (t _FieldTypeTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__type_description_interfaces__msg__FieldType())
}

type CFieldType = C.type_description_interfaces__msg__FieldType
type CFieldType__Sequence = C.type_description_interfaces__msg__FieldType__Sequence

func FieldType__Sequence_to_Go(goSlice *[]FieldType, cSlice CFieldType__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]FieldType, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		FieldTypeTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func FieldType__Sequence_to_C(cSlice *CFieldType__Sequence, goSlice []FieldType) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.type_description_interfaces__msg__FieldType)(C.malloc(C.sizeof_struct_type_description_interfaces__msg__FieldType * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		FieldTypeTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func FieldType__Array_to_Go(goSlice []FieldType, cSlice []CFieldType) {
	for i := 0; i < len(cSlice); i++ {
		FieldTypeTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func FieldType__Array_to_C(cSlice []CFieldType, goSlice []FieldType) {
	for i := 0; i < len(goSlice); i++ {
		FieldTypeTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
