// Code generated by rclgo-gen. DO NOT EDIT.

package ros_gz_interfaces_msg
import (
	"unsafe"

	"github.com/ATIinc/rclgo/pkg/rclgo"
	"github.com/ATIinc/rclgo/pkg/rclgo/types"
	"github.com/ATIinc/rclgo/pkg/rclgo/typemap"
	primitives "github.com/ATIinc/rclgo/pkg/rclgo/primitives"
	geometry_msgs_msg "github.com/iema-group/goros2/msgs/geometry_msgs/msg"
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <ros_gz_interfaces/msg/entity_factory.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("ros_gz_interfaces/EntityFactory", EntityFactoryTypeSupport)
	typemap.RegisterMessage("ros_gz_interfaces/msg/EntityFactory", EntityFactoryTypeSupport)
}

type EntityFactory struct {
	Name string `yaml:"name" json:"name" mapstructure:"name"`// New name for the entity, overrides the name on the SDF
	AllowRenaming bool `yaml:"allow_renaming" json:"allow_renaming" mapstructure:"allow_renaming"`// Whether the server is allowed to rename the entity in case of
	Sdf string `yaml:"sdf" json:"sdf" mapstructure:"sdf"`// SDF description in string format. Only one method is supported at a time (sdf,sdf_filename,clone_name)
	SdfFilename string `yaml:"sdf_filename" json:"sdf_filename" mapstructure:"sdf_filename"`// Full path to SDF file.
	CloneName string `yaml:"clone_name" json:"clone_name" mapstructure:"clone_name"`// Name of entity to clone
	Pose geometry_msgs_msg.Pose `yaml:"pose" json:"pose" mapstructure:"pose"`// Pose where the entity will be spawned in the world.
	RelativeTo string `yaml:"relative_to" json:"relative_to" mapstructure:"relative_to"`// Pose is defined relative to the frame of this entity.
}

// NewEntityFactory creates a new EntityFactory with default values.
func NewEntityFactory() *EntityFactory {
	self := EntityFactory{}
	self.SetDefaults()
	return &self
}

func (t *EntityFactory) Clone() *EntityFactory {
	c := &EntityFactory{}
	c.Name = t.Name
	c.AllowRenaming = t.AllowRenaming
	c.Sdf = t.Sdf
	c.SdfFilename = t.SdfFilename
	c.CloneName = t.CloneName
	c.Pose = *t.Pose.Clone()
	c.RelativeTo = t.RelativeTo
	return c
}

func (t *EntityFactory) CloneMsg() types.Message {
	return t.Clone()
}

func (t *EntityFactory) SetDefaults() {
	t.Name = ""
	t.AllowRenaming = false              
	t.Sdf = ""
	t.SdfFilename = ""
	t.CloneName = ""
	t.Pose.SetDefaults()
	t.RelativeTo = "world\"             "
}

func (t *EntityFactory) GetTypeSupport() types.MessageTypeSupport {
	return EntityFactoryTypeSupport
}

// EntityFactoryPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type EntityFactoryPublisher struct {
	*rclgo.Publisher
}

// NewEntityFactoryPublisher creates and returns a new publisher for the
// EntityFactory
func NewEntityFactoryPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*EntityFactoryPublisher, error) {
	pub, err := node.NewPublisher(topic_name, EntityFactoryTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &EntityFactoryPublisher{pub}, nil
}

func (p *EntityFactoryPublisher) Publish(msg *EntityFactory) error {
	return p.Publisher.Publish(msg)
}

// EntityFactorySubscription wraps rclgo.Subscription to provide type safe helper
// functions
type EntityFactorySubscription struct {
	*rclgo.Subscription
}

// EntityFactorySubscriptionCallback type is used to provide a subscription
// handler function for a EntityFactorySubscription.
type EntityFactorySubscriptionCallback func(msg *EntityFactory, info *rclgo.MessageInfo, err error)

// NewEntityFactorySubscription creates and returns a new subscription for the
// EntityFactory
func NewEntityFactorySubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback EntityFactorySubscriptionCallback) (*EntityFactorySubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg EntityFactory
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, EntityFactoryTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &EntityFactorySubscription{sub}, nil
}

func (s *EntityFactorySubscription) TakeMessage(out *EntityFactory) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneEntityFactorySlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneEntityFactorySlice(dst, src []EntityFactory) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var EntityFactoryTypeSupport types.MessageTypeSupport = _EntityFactoryTypeSupport{}

type _EntityFactoryTypeSupport struct{}

func (t _EntityFactoryTypeSupport) New() types.Message {
	return NewEntityFactory()
}

func (t _EntityFactoryTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.ros_gz_interfaces__msg__EntityFactory
	return (unsafe.Pointer)(C.ros_gz_interfaces__msg__EntityFactory__create())
}

func (t _EntityFactoryTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.ros_gz_interfaces__msg__EntityFactory__destroy((*C.ros_gz_interfaces__msg__EntityFactory)(pointer_to_free))
}

func (t _EntityFactoryTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*EntityFactory)
	mem := (*C.ros_gz_interfaces__msg__EntityFactory)(dst)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.name), m.Name)
	mem.allow_renaming = C.bool(m.AllowRenaming)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.sdf), m.Sdf)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.sdf_filename), m.SdfFilename)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.clone_name), m.CloneName)
	geometry_msgs_msg.PoseTypeSupport.AsCStruct(unsafe.Pointer(&mem.pose), &m.Pose)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.relative_to), m.RelativeTo)
}

func (t _EntityFactoryTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*EntityFactory)
	mem := (*C.ros_gz_interfaces__msg__EntityFactory)(ros2_message_buffer)
	primitives.StringAsGoStruct(&m.Name, unsafe.Pointer(&mem.name))
	m.AllowRenaming = bool(mem.allow_renaming)
	primitives.StringAsGoStruct(&m.Sdf, unsafe.Pointer(&mem.sdf))
	primitives.StringAsGoStruct(&m.SdfFilename, unsafe.Pointer(&mem.sdf_filename))
	primitives.StringAsGoStruct(&m.CloneName, unsafe.Pointer(&mem.clone_name))
	geometry_msgs_msg.PoseTypeSupport.AsGoStruct(&m.Pose, unsafe.Pointer(&mem.pose))
	primitives.StringAsGoStruct(&m.RelativeTo, unsafe.Pointer(&mem.relative_to))
}

func (t _EntityFactoryTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__ros_gz_interfaces__msg__EntityFactory())
}

type CEntityFactory = C.ros_gz_interfaces__msg__EntityFactory
type CEntityFactory__Sequence = C.ros_gz_interfaces__msg__EntityFactory__Sequence

func EntityFactory__Sequence_to_Go(goSlice *[]EntityFactory, cSlice CEntityFactory__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]EntityFactory, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		EntityFactoryTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func EntityFactory__Sequence_to_C(cSlice *CEntityFactory__Sequence, goSlice []EntityFactory) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.ros_gz_interfaces__msg__EntityFactory)(C.malloc(C.sizeof_struct_ros_gz_interfaces__msg__EntityFactory * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		EntityFactoryTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func EntityFactory__Array_to_Go(goSlice []EntityFactory, cSlice []CEntityFactory) {
	for i := 0; i < len(cSlice); i++ {
		EntityFactoryTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func EntityFactory__Array_to_C(cSlice []CEntityFactory, goSlice []EntityFactory) {
	for i := 0; i < len(goSlice); i++ {
		EntityFactoryTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
