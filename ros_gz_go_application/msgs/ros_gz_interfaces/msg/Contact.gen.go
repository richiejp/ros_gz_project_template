// Code generated by rclgo-gen. DO NOT EDIT.

package ros_gz_interfaces_msg
import (
	"unsafe"

	"github.com/ATIinc/rclgo/pkg/rclgo"
	"github.com/ATIinc/rclgo/pkg/rclgo/types"
	"github.com/ATIinc/rclgo/pkg/rclgo/typemap"
	primitives "github.com/ATIinc/rclgo/pkg/rclgo/primitives"
	geometry_msgs_msg "github.com/iema-group/goros2/msgs/geometry_msgs/msg"
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <ros_gz_interfaces/msg/contact.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("ros_gz_interfaces/Contact", ContactTypeSupport)
	typemap.RegisterMessage("ros_gz_interfaces/msg/Contact", ContactTypeSupport)
}

type Contact struct {
	Collision1 Entity `yaml:"collision1" json:"collision1" mapstructure:"collision1"`// Contact collision1
	Collision2 Entity `yaml:"collision2" json:"collision2" mapstructure:"collision2"`// Contact collision2
	Positions []geometry_msgs_msg.Vector3 `yaml:"positions" json:"positions" mapstructure:"positions"`// List of contact position
	Normals []geometry_msgs_msg.Vector3 `yaml:"normals" json:"normals" mapstructure:"normals"`// List of contact normals
	Depths []float64 `yaml:"depths" json:"depths" mapstructure:"depths"`// List of penetration depths
	Wrenches []JointWrench `yaml:"wrenches" json:"wrenches" mapstructure:"wrenches"`// List of joint wrenches including forces/torques
}

// NewContact creates a new Contact with default values.
func NewContact() *Contact {
	self := Contact{}
	self.SetDefaults()
	return &self
}

func (t *Contact) Clone() *Contact {
	c := &Contact{}
	c.Collision1 = *t.Collision1.Clone()
	c.Collision2 = *t.Collision2.Clone()
	if t.Positions != nil {
		c.Positions = make([]geometry_msgs_msg.Vector3, len(t.Positions))
		geometry_msgs_msg.CloneVector3Slice(c.Positions, t.Positions)
	}
	if t.Normals != nil {
		c.Normals = make([]geometry_msgs_msg.Vector3, len(t.Normals))
		geometry_msgs_msg.CloneVector3Slice(c.Normals, t.Normals)
	}
	if t.Depths != nil {
		c.Depths = make([]float64, len(t.Depths))
		copy(c.Depths, t.Depths)
	}
	if t.Wrenches != nil {
		c.Wrenches = make([]JointWrench, len(t.Wrenches))
		CloneJointWrenchSlice(c.Wrenches, t.Wrenches)
	}
	return c
}

func (t *Contact) CloneMsg() types.Message {
	return t.Clone()
}

func (t *Contact) SetDefaults() {
	t.Collision1.SetDefaults()
	t.Collision2.SetDefaults()
	t.Positions = nil
	t.Normals = nil
	t.Depths = nil
	t.Wrenches = nil
}

func (t *Contact) GetTypeSupport() types.MessageTypeSupport {
	return ContactTypeSupport
}

// ContactPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type ContactPublisher struct {
	*rclgo.Publisher
}

// NewContactPublisher creates and returns a new publisher for the
// Contact
func NewContactPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*ContactPublisher, error) {
	pub, err := node.NewPublisher(topic_name, ContactTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &ContactPublisher{pub}, nil
}

func (p *ContactPublisher) Publish(msg *Contact) error {
	return p.Publisher.Publish(msg)
}

// ContactSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type ContactSubscription struct {
	*rclgo.Subscription
}

// ContactSubscriptionCallback type is used to provide a subscription
// handler function for a ContactSubscription.
type ContactSubscriptionCallback func(msg *Contact, info *rclgo.MessageInfo, err error)

// NewContactSubscription creates and returns a new subscription for the
// Contact
func NewContactSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback ContactSubscriptionCallback) (*ContactSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg Contact
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, ContactTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &ContactSubscription{sub}, nil
}

func (s *ContactSubscription) TakeMessage(out *Contact) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneContactSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneContactSlice(dst, src []Contact) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var ContactTypeSupport types.MessageTypeSupport = _ContactTypeSupport{}

type _ContactTypeSupport struct{}

func (t _ContactTypeSupport) New() types.Message {
	return NewContact()
}

func (t _ContactTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.ros_gz_interfaces__msg__Contact
	return (unsafe.Pointer)(C.ros_gz_interfaces__msg__Contact__create())
}

func (t _ContactTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.ros_gz_interfaces__msg__Contact__destroy((*C.ros_gz_interfaces__msg__Contact)(pointer_to_free))
}

func (t _ContactTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*Contact)
	mem := (*C.ros_gz_interfaces__msg__Contact)(dst)
	EntityTypeSupport.AsCStruct(unsafe.Pointer(&mem.collision1), &m.Collision1)
	EntityTypeSupport.AsCStruct(unsafe.Pointer(&mem.collision2), &m.Collision2)
	geometry_msgs_msg.Vector3__Sequence_to_C((*geometry_msgs_msg.CVector3__Sequence)(unsafe.Pointer(&mem.positions)), m.Positions)
	geometry_msgs_msg.Vector3__Sequence_to_C((*geometry_msgs_msg.CVector3__Sequence)(unsafe.Pointer(&mem.normals)), m.Normals)
	primitives.Float64__Sequence_to_C((*primitives.CFloat64__Sequence)(unsafe.Pointer(&mem.depths)), m.Depths)
	JointWrench__Sequence_to_C(&mem.wrenches, m.Wrenches)
}

func (t _ContactTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*Contact)
	mem := (*C.ros_gz_interfaces__msg__Contact)(ros2_message_buffer)
	EntityTypeSupport.AsGoStruct(&m.Collision1, unsafe.Pointer(&mem.collision1))
	EntityTypeSupport.AsGoStruct(&m.Collision2, unsafe.Pointer(&mem.collision2))
	geometry_msgs_msg.Vector3__Sequence_to_Go(&m.Positions, *(*geometry_msgs_msg.CVector3__Sequence)(unsafe.Pointer(&mem.positions)))
	geometry_msgs_msg.Vector3__Sequence_to_Go(&m.Normals, *(*geometry_msgs_msg.CVector3__Sequence)(unsafe.Pointer(&mem.normals)))
	primitives.Float64__Sequence_to_Go(&m.Depths, *(*primitives.CFloat64__Sequence)(unsafe.Pointer(&mem.depths)))
	JointWrench__Sequence_to_Go(&m.Wrenches, mem.wrenches)
}

func (t _ContactTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__ros_gz_interfaces__msg__Contact())
}

type CContact = C.ros_gz_interfaces__msg__Contact
type CContact__Sequence = C.ros_gz_interfaces__msg__Contact__Sequence

func Contact__Sequence_to_Go(goSlice *[]Contact, cSlice CContact__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]Contact, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		ContactTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func Contact__Sequence_to_C(cSlice *CContact__Sequence, goSlice []Contact) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.ros_gz_interfaces__msg__Contact)(C.malloc(C.sizeof_struct_ros_gz_interfaces__msg__Contact * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		ContactTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func Contact__Array_to_Go(goSlice []Contact, cSlice []CContact) {
	for i := 0; i < len(cSlice); i++ {
		ContactTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func Contact__Array_to_C(cSlice []CContact, goSlice []Contact) {
	for i := 0; i < len(goSlice); i++ {
		ContactTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
